if !htmlWebpackPlugin.options
	- htmlWebpackPlugin.options = {};

//- adds title, to be used in <head>
mixin title
	title= htmlWebpackPlugin.options.title

//- adds favicon, to be used in <head>
mixin favicon
	if htmlWebpackPlugin.files.favicon
		link(rel='shortcut icon', href=htmlWebpackPlugin.files.favicon)

//- adds mobile meta tag, to be used in <head>
mixin mobile
	if htmlWebpackPlugin.options.mobile
		meta(name='viewport', content='width=device-width, initial-scale=1, shrink-to-fit=no')

//- adds a div tag for each supplied id
	@ids can be an Array or a single id,
	if none supplied uses appMountId and appMountIds
	also accepts attributes to be added to div tags,
	appMount("id")(class="mount-point")
mixin appMount(ids)
	if ids === undefined
		if htmlWebpackPlugin.options.appMountId
			div(id=htmlWebpackPlugin.options.appMountId)&attributes(attributes)

		if htmlWebpackPlugin.options.appMountIds
			each appMountId in htmlWebpackPlugin.options.appMountIds
				div(id=appMountId)&attributes(attributes)

	else
		if !Array.isArray(ids)
			- ids = [ids];
		each id in ids
			div(id=id)&attributes(attributes)
				

- const selfclosingTags =  new Set(["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"]);

//- 
	injects extra resources
	@extras is an Array of {tag, ..rest} objects or strings;
	objects must have valid tag property,
	strings must end with ".css" or ".js" to be converted into valid objects;
	innerHTML property of an object is included as innerHTML in non-self-closing tags,
	other truthy properties of an object are added as attributes to the constructed tag
mixin injectExtras(extras)
	each item in extras
		if typeof item === "string" || item instanceof String
			if item.endsWith(".css")
				- item = {tag: "link", href: item, rel: "stylesheet"};
			else if item.endsWith(".js")
				- item = {tag: "script", src: item};
			else
				- throw new Error("Can't deduce tag from filename: " + item);
		else if !item.tag
			- throw new Error("Item " + JSON.stringify(item) + " must have a valid tag property")
			
		- const attrs = Object.assign({}, item, {tag: null, innerHTML: null});
		if selfclosingTags.has(item.tag)
			#{item.tag}&attributes(attrs)/
		else
			#{item.tag}&attributes(attrs)!= item.innerHTML
			
//- 
	injects extra resources passed in injectExtras.head from htmlWebpackPlugin.options
mixin injectExtrasHead
	if htmlWebpackPlugin.options.injectExtras && htmlWebpackPlugin.options.injectExtras.head
		+injectExtras(htmlWebpackPlugin.options.injectExtras.head)

//- 
	injects extra resources passed in injectExtras.body from htmlWebpackPlugin.options	
mixin injectExtrasBody
	if htmlWebpackPlugin.options.injectExtras && htmlWebpackPlugin.options.injectExtras.body
		+injectExtras(htmlWebpackPlugin.options.injectExtras.body)
				


- const inlined = new Set(), injected = new Set();
- const cssToInline = [], jsToInline = [], jsToInject = [];
- let cssToInject = [];
- const toInline = htmlWebpackPlugin.options.inline && new Set(Array.isArray(htmlWebpackPlugin.options.inline) ? htmlWebpackPlugin.options.inline : [htmlWebpackPlugin.options.inline]);
- const substrStart = htmlWebpackPlugin.files.publicPath ? htmlWebpackPlugin.files.publicPath.length : 0;
- const excludeJSWithCSS = htmlWebpackPlugin.options.excludeJSWithCSS;
- const excludeJSChunks = htmlWebpackPlugin.options.excludeJSChunks && new Set(Array.isArray(htmlWebpackPlugin.options.excludeJSChunks) ? htmlWebpackPlugin.options.excludeJSChunks : [htmlWebpackPlugin.options.excludeJSChunks]);

//- if inline array was supplied gather which resources to inline and which to inject
if toInline
	each chunk, name in htmlWebpackPlugin.files.chunks
		if excludeJSWithCSS && chunk.css && chunk.css.length > 0
			- Array.prototype.push.apply(toInline.has(name) ? cssToInline : cssToInject, chunk.css);
			- continue;

		if excludeJSChunks && excludeJSChunks.has(name)
			if chunk.css && chunk.css.length > 0
				- Array.prototype.push.apply(toInline.has(name) ? cssToInline : cssToInject, chunk.css);
			- continue;

		if toInline.has(name)
			- jsToInline.push(chunk.entry);
			if chunk.css && chunk.css.length > 0
				- Array.prototype.push.apply(cssToInline, chunk.css);
		else
			- jsToInject.push(chunk.entry);
			if chunk.css && chunk.css.length > 0
				- Array.prototype.push.apply(cssToInject, chunk.css);
//- otherwise all resources by default except for specifically excluded with excludeJSChunks or excludeJSWithCSS
else
	- cssToInject = htmlWebpackPlugin.files.css.slice();
	each chunk, name in htmlWebpackPlugin.files.chunks
		if (excludeJSWithCSS && chunk.css && chunk.css.length > 0) || (excludeJSChunks && excludeJSChunks.has(name))
			- continue;
		- jsToInject.push(chunk.entry);


//- 
	gathers files matching filename from searchWithin
	@filename string or regexp to filter for
	@searchWithin Array of files, equals to htmlWebpackPlugin.files by default
- function gatherFiles(filename, searchWithin = htmlWebpackPlugin.files.css.concat(htmlWebpackPlugin.files.js)) {	
	if filename instanceof RegExp
		- return searchWithin.filter(fn => filename.test(fn));
	else
		- return searchWithin.indexOf(filename) !== -1 ? [filename] : [];
- }

//-
	inlines a resource in a tag
	@filename is a string or a RegExp to be compared against htmlWebpackPlugin.files
	@tag if not provided is deduced from file extension
	@searchWithin -- array of filenames to match against RegExp @filename,
	equals to [...css, ...js] from htmlWebpackPlugin.files by default
mixin inline(filename, tag, searchWithin)
	- const files = gatherFiles(filename, searchWithin)
	if files.length === 0
		- console.warn("WARNING Nothing to inline for %s query", filename);
	each file in files
		- const currentTag = tag || (file.endsWith(".css") ? "style" : file.endsWith(".js") ? "script" : "div");

		#{currentTag}&attributes(attributes) !{compilation.assets[file.substr(substrStart)].source()}

		- inlined.add(file);

//-
	injects a resource in a tag
	@filename is a string or a RegExp to be compared against htmlWebpackPlugin.files
	@tag if not provided is deduced from file extension
	@searchWithin -- array of filenames to match against RegExp @filename,
	equals to [...css, ...js] from htmlWebpackPlugin.files by default
mixin inject(filename, tag, searchWithin)
	- const files = gatherFiles(filename)
	if files.length === 0
		- console.warn("WARNING Nothing to inject for %s query", filename);
	each file in files
		- const currentTag = tag || (file.endsWith(".css") ? "link" : file.endsWith(".js") ? "script" : "div");
		if currentTag === "link"
			link(rel="stylesheet", href=file)&attributes(attributes)
		else if currentTag === "script"
			script(src=file)&attributes(attibutes)
		else
			#{currentTag}&attributes(attributes)

		- injected.add(file);




//-
	inlines css resources from htmlWebpackPlugin.files,
	except for already inlined or injected resources
	@cssList can be a single filename string, RegExp or an array of them,
	cssList strings starting with "!" are skipped
mixin inlineCSS(cssList = cssToInline)
	- const {include, exclude} = constructIncludeExclude(cssList, cssToInline);

	- processRc(include, (css) => {
			+inline(css, "style", htmlWebpackPlugin.files.css)
	- }, exclude);


//-
	injects css resources from htmlWebpackPlugin.files,
	except for already inlined or injected resources
	@cssList can be a single filename string, RegExp or an array of them,
	cssList strings starting with "!" are skipped
mixin injectCSS(cssList = cssToInject)
	- const {include, exclude} = constructIncludeExclude(cssList, cssToInject);

	- processRc(include, (css) => {
			+inject(css, "link", htmlWebpackPlugin.files.css)
	- }, exclude);


//-
	inlines js resources from htmlWebpackPlugin.files,
	except for already inlined or injected resources
	@jsList can be a single filename string, RegExp or an array of them,
	jsList strings starting with "!" are skipped
mixin inlineJS(jsList = jsToInline)
	- const {include, exclude} = constructIncludeExclude(jsList, jsToInline);

	- processRc(include, (js) => {
			+inline(js, "script", htmlWebpackPlugin.files.js)
	- }, exclude);


//-
	injects js resources from htmlWebpackPlugin.files,
	except for already inlined or injected resources
	@jsList can be a single filename string, RegExp or an array of them,
	jsList strings starting with "!" are skipped
mixin injectJS(jsList = jsToInject)
	- const {include, exclude} = constructIncludeExclude(jsList, jsToInline);

	- processRc(include, (js) => {
			+inject(js, "script", htmlWebpackPlugin.files.js)
	- }, exclude);


//-
	inlines css resources from chunks passed in htmlWebpackPlugin.options.inline
	andinjects the rest, in the order they appear htmlWebpackPlugin.files
mixin CSS
	each css in htmlWebpackPlugin.files.css
		if injected.has(css) || inlined.has(css)
			- continue;

		if cssToInline.includes(css)
			+inline(css, "style")
		else if cssToInject.includes(css)
			+inject(css, "link")


//-
	inlines js resources from chunks passed in htmlWebpackPlugin.options.inline
	and injects the rest, in the order they appear htmlWebpackPlugin.files
mixin JS
	each js in htmlWebpackPlugin.files.js
		if injected.has(js) || inlined.has(js)
			- continue;

		if jsToInline.includes(js)
			+inline(js, "script")
		else if jsToInject.includes(js)
			+inject(js, "script")


//-
	processes a single resource or a list of resources,
	except for already inlined or injected resources,
	calling cb function on each
	@rcList can be a single filename string, RegExp or an array of them,
	rcList elements contained in excludeSet are skipped
- function processRc(rcList, cb, excludeSet) {
	if !Array.isArray(rcList)
		- rcList = [rcList];

	each rc in rcList
		if !injected.has(rc) && !inlined.has(rc) && !excludeSet.has(rc)
			- cb(rc);
- }


//-
	constructs an include string or Array and an exclude Set
	elements from @set starting with "!" go into exclude Set,
	if set consists only of !elements, include = @defaultSet
	@set can be a single filename string with an optional "!" prefix
	or an Array of such strings
	@defaultSet is an Array to include by default in case of a fully exclusive @set 
- function constructIncludeExclude(set, defaultSet) {
	- let include, exclude;
	if (typeof set === "string" || set instanceof String) && set.startsWith("!")
		- exclude = new Set().add(set.slice(1));
		- include = defaultSet;
	else if Array.isArray(set)
		- const filtered = set.filter(css => (typeof css === "string" || css instanceof String) && css.startsWith("!"));
		- exclude = new Set(filtered);
		//- if set contains only excludes("!") consider include = defaultSet, otherwise = actual set
		- include = filtered.length === set.length ? defaultSet : set;
	else
		- include = set;
		- exclude = new Set();

	- return {include, exclude};
- }


//-
	inlines files of type @type from chunk with @chunkName name
	@chunkName - a valid chunk name from htmlWebpackPlugin.files.chunks or an array of names
	@type - can be "css", "js", which inlines css or js files respectively,
	otherwise inlines both types
mixin inlineChunk(chunkNames, type)
	if !Array.isArray(chunkNames)
		- chunkNames = [chunkNames];
		
	each chunkName in chunkNames
		- const chunk = htmlWebpackPlugin.files.chunks[chunkName];
		if !chunk
			- console.warn("No such chunk", chunkName);
			- continue;
		
		if type === "css"
			each file in chunk.css
				style !{compilation.assets[file.substr(substrStart)].source()}
				- inlined.add(file);
			else
				- console.warn("No css files in %s chunk", chunkName);
		else if type === "js"
			script !{compilation.assets[chunk.entry.substr(substrStart)].source()}
			- inlined.add(chunk.entry);
		else
			each file in chunk.css
				style !{compilation.assets[file.substr(substrStart)].source()}
				- inlined.add(file);
				
			script !{compilation.assets[chunk.entry.substr(substrStart)].source()}
			- inlined.add(chunk.entry);
	

//-
	injects files of type @type from chunk with @chunkName name
	@chunkName - a valid chunk name from htmlWebpackPlugin.files.chunks or an array of names
	@type - can be "css", "js", which injects css or js files respectively,
	otherwise injects both types
mixin injectChunk(chunkNames, type)
	if !Array.isArray(chunkNames)
		- chunkNames = [chunkNames];
		
	each chunkName in chunkNames
		- const chunk = htmlWebpackPlugin.files.chunks[chunkName];
		if !chunk
			- console.warn("No such chunk", chunkName);
			- continue;
		
		if type === "css"
			each file in chunk.css
				link(rel="stylesheet", href=file)
				- injected.add(file);
			else
				- console.warn("No css files in %s chunk", chunkName);
		else if type === "js"
			script(src=chunk.entry)
			- injected.add(chunk.entry);
		else
			each file in chunk.css
				link(rel="stylesheet", href=file)
				- injected.add(file);
				
			script(src=chunk.entry)
			- injected.add(chunk.entry);

		
